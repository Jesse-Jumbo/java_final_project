<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Typing Game</title>
    <style>
        body {
            margin: 0;
            background: black;
            overflow: hidden;
            font-family: monospace;
        }

        #gameArea {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameOverMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .menu {
            text-align: center;
        }

        .menu h1 {
            font-size: 3rem;
            margin-bottom: 2rem;
        }

        .menu button {
            margin: 1rem;
            padding: 1rem 2rem;
            font-size: 1.2rem;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: #333;
            color: white;
            transition: background-color 0.3s ease;
        }

        .menu button:hover {
            background-color: #555;
        }

        #ship {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 30px;
            background-color: white;
            border-radius: 10px;
        }

        .meteor {
            position: absolute;
            font-size: 2rem;
            color: cyan;
        }

        .bullet {
            position: absolute;
            width: 6px;
            height: 20px;
            background-color: red;
        }

        .wrong {
            color: red;
            font-weight: bold;
        }

        #lives {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 1.5rem;
            color: white;
        }
    </style>
</head>
<body>

<div id="gameArea"></div>
<div id="ship"></div>
<div id="lives">â¤ï¸ x 10</div>
<div id="gameOverMenu" style="display: none;">
    <div class="menu">
        <h1>ğŸ’€ Game Over</h1>
        <button onclick="restartGame()">ğŸ” é‡æ–°é–‹å§‹</button>
        <button onclick="goHome()">ğŸ  å›åˆ°é¦–é </button>
    </div>
</div>

<script>
    const gameArea = document.getElementById("gameArea");
    const ship = document.getElementById("ship");
    const livesDiv = document.getElementById("lives");

    let activeMeteors = [];
    let lockedTarget = null;
    let isGameOver = false;
    let nextSpawnTimeout = null;


    function renderMeteorText(meteor) {
        return [...meteor.remaining].map(ch => `<span>${ch}</span>`).join("");
    }

    function updateLives(lives) {
        livesDiv.innerText = `â¤ï¸ x ${lives}`;
    }

    function shootBullet(targetMeteor) {
        const bullet = document.createElement("div");
        bullet.className = "bullet";

        const shipBox = ship.getBoundingClientRect();
        const meteorBox = targetMeteor.element.getBoundingClientRect();

        const startX = shipBox.left + shipBox.width / 2;
        const startY = shipBox.top;
        const endX = meteorBox.left + meteorBox.width / 2;
        const endY = meteorBox.top + 10;

        bullet.style.left = `${startX}px`;
        bullet.style.top = `${startY}px`;
        bullet.style.transition = "top 0.5s linear, left 0.5s linear";
        gameArea.appendChild(bullet);

        setTimeout(() => {
            bullet.style.left = `${endX}px`;
            bullet.style.top = `${endY}px`;
        }, 10);

        setTimeout(() => bullet.remove(), 600);
    }

    async function handleDefeat(word) {
        try {
            await fetch("/api/defeat", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(word)
            });
        } catch (err) {
            console.error("å›å ± defeat å¤±æ•—ï¼š", err);
        }
    }

    document.addEventListener("keydown", async (event) => {
        const key = event.key.toLowerCase();

        if (!lockedTarget) {
            for (let meteor of activeMeteors) {
                if (meteor.remaining.toLowerCase().startsWith(key)) {
                    lockedTarget = meteor;
                    break;
                }
            }
        }

        if (lockedTarget) {
            const expected = lockedTarget.remaining.charAt(0).toLowerCase();
            const spans = lockedTarget.element.querySelectorAll("span");
            if (spans.length > 0) spans[0].classList.remove("wrong");

            if (key === expected) {
                shootBullet(lockedTarget);
                lockedTarget.remaining = lockedTarget.remaining.substring(1);

                if (lockedTarget.remaining.length > 0) {
                    lockedTarget.element.innerHTML = renderMeteorText(lockedTarget);
                } else {
                    await handleDefeat(lockedTarget.originalWord);
                    lockedTarget.element.innerText = lockedTarget.definition;
                    lockedTarget.element.style.color = "yellow";
                    lockedTarget = null;
                }
            } else {
                if (spans.length > 0) spans[0].classList.add("wrong");
            }
        }
    });


    function renderMeteorTextFromString(str) {
        return [...str].map(ch => `<span>${ch}</span>`).join("");
    }

    function showGameOverMenu() {
        document.getElementById("gameOverMenu").style.display = "flex";
        if (nextSpawnTimeout) {
            clearTimeout(nextSpawnTimeout);
            nextSpawnTimeout = null;
        }
    }

    function restartGame() {
        updateLives(10); // é è¨­ 10 æ¢å‘½

        // æ¸…é™¤ä¸‹ä¸€é¡Œæ’ç¨‹
        if (nextSpawnTimeout) {
            clearTimeout(nextSpawnTimeout);
            nextSpawnTimeout = null;
        }

        // åœæ­¢æ‰€æœ‰éš•çŸ³æ‰è½å‹•ç•« & ç§»é™¤ç•«é¢ä¸Šçš„éš•çŸ³
        activeMeteors.forEach(meteor => {
            if (meteor.fallInterval) clearInterval(meteor.fallInterval);
            meteor.element.remove();
        });

        // æ¸…ç©ºç‹€æ…‹
        activeMeteors = [];
        lockedTarget = null;
        isGameOver = false;

        // éš±è— Game Over èœå–®
        document.getElementById("gameOverMenu").style.display = "none";

        // é‡ç½®å¾Œç«¯ç‹€æ…‹ï¼Œä¸¦é–‹å§‹æ–°ä¸€è¼ª
        fetch("/api/reset", { method: "POST" })
            .then(() => {
                spawnMeteorFromAPI(); // é¦¬ä¸Šå‡ºç¬¬ä¸€é¡Œ
            });
    }

    function goHome() {
        window.location.href = "/";
    }

    async function spawnMeteorFromAPI() {
        const res = await fetch("/api/next-word");
        const data = await res.json();

        if (data.gameOver) {
            showGameOverMenu();
            return;
        }

        updateLives(data.lives);

        const meteor = document.createElement("div");
        meteor.className = "meteor";
        meteor.innerHTML = renderMeteorTextFromString(data.word);
        meteor.style.left = `${Math.random() * 80 + 10}%`;
        meteor.style.top = "0px";
        gameArea.appendChild(meteor);

        const meteorObj = {
            element: meteor,
            remaining: data.word,
            originalWord: data.word,
            definition: data.definition,
            y: 0,
            fallInterval: null
        };

        activeMeteors.push(meteorObj);

        meteorObj.fallInterval = setInterval(async () => {
            meteorObj.y += 2;
            meteor.style.top = `${meteorObj.y}px`;

            if (meteorObj.y >= window.innerHeight - 50) {
                clearInterval(meteorObj.fallInterval);

                if (meteorObj.remaining.length > 0) {
                    const lostRes = await fetch("/api/life/lost", { method: "POST" });
                    const lostData = await lostRes.json();

                    if (lostData.gameOver) {
                        showGameOverMenu();
                        return;
                    }
                    updateLives(lostData.lives);
                    spawnMeteorFromAPI(); // ç¹¼çºŒå‡ºä¸‹ä¸€é¡Œ
                }

                meteor.remove();
                activeMeteors = activeMeteors.filter(m => m !== meteorObj);
                if (lockedTarget === meteorObj) lockedTarget = null;
            }
        }, Math.max(data.durationMs / 200, 30));

        // â—é‡é»ï¼šåªæœ‰åœ¨ Java å›å‚³ gameOver = false æ™‚æ‰é€²å…¥é€™è£¡
        if (!data.gameOver) {
            nextSpawnTimeout = setTimeout(spawnMeteorFromAPI, data.durationMs);
        }
    }

    // éŠæˆ²é–‹å§‹
    spawnMeteorFromAPI();
</script>
</body>
</html>
